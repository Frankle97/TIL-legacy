# 순환 참조 (Circular Reference)

AService가 BService를 의존하고, BService가 AService를 의존하는 상황, 즉 서로가 서로를 참조하고 있는 경우를 **순환 참조**라고 한다.

> *ex) new AService(new BService(new AService(new BService)))...*
> 

이러한 상황에서 AService가 메모리에 오르기 전에 BService 의존 주입을 하는 상황 혹은 그 반대에 경우에 문제가 발생한다.

## 의존 주입 방법에 따른 차이

- **필드 주입**과 **수정자 주입**은 순환 참조 구조를 파악할 수 없다.
- **생성자 주입**은 순환참조 구조의 빈이 있다면 어플리케이션이 구동에 실패하고 순환참조 에러를 발생시킨다.
    
    ### **의존성** **주입 방법마다 다른 의존 주입 시점**
    
    1. **필드 주입과** **수정자 주입**
        
        객체를 먼저 생성하고 필요한 의존성을 주입하여 빈으로 등록한다.
        
    2. **생성자 주입**
        
        객체를 생성하는 시점에 생성자 인자에 해당하는 빈을 빈 팩토리에서 찾아서 주입하거나 해당 빈이 빈 팩토리에 존재하지 않다면 
        
        인자에 해당하는 빈을 우선 생성하고 주입한 뒤, 객체를 생성하고 빈으로 등록한다.
        

## 생성자 주입의 구체적인 원리

AService가 BService를 의존하고, BService가 CService를 의존한다고 가정해보자.

스프링 어플리케이션 로딩 시점에 빈 팩토리에선 클래스들에 대한 의존 관계 주입을 진행한다.

AService 빈을 만들기 위해서 생성자 인자인 BService 빈을 탐색하고 없으면 BService 빈 먼저 생성한다. 

여기서 BService 클래스의 빈을 만드려하니 이번엔 CService 빈이 없으므로 CService 빈을 생성하게 된다.

빈 생성 순서는 `C→B→A` 순서로 생성하는 것을 알 수 있다.

## 스프링이 순환 참조를 발견하는 과정

그렇다면, 이번에는 `AService`가 `BService`를 의존하고 BService가 AService를 서로 의존하는 상황이라고 가정해보자.

AService 빈을 생성하려면 생성자 인자인 BService 빈을 주입하기 위해 탐색하고 없으면, BService 빈을 생성하여 인자로 주입해야 하는데 BService 빈을 생성하기 위해 BService의 생성자 인자인 AService 빈을 생성하려하니 AService의 빈을 생성하는 과정에서는 또 생성자 인자인 BService를 찾고.. 이 과정이 무한 반복에 빠지게 되면서 스프링에서 순환 참조 에러를 발생시킨다.

## 해결 방법

1. @Lazy 어노테이션 사용
    
    해당 어노테이션을 사용한다면 어플리케이션 기동 시점이 아닌 해당 빈이 필요한 시점에 빈을 생성하기 때문에 HTTP 요청 받았을 때, 힙 메모리가 증가할 수 있으며 메모리가 충분하지 않을 경우 장애로 이어질 가능성이 있다. 

    또한 스프링에서도 권장하지 않는 방식이기 때문에 사용을 지양한다.

2. 설계 변경
    
    순환 참조의 연결고리를 끊는 것 즉, 설계 자체를 수정하는 것이 가장 좋은 방법이다. 
    수정자 또는 필드 주입을 사용하여 우회적으로 순환 참조에 벗어난다 하더라도 똑같은 문제가 이후에 발생할 여지를 남기는 것이기에 미연에 순환참조를 방지하도록 설계를 고치자.
    
    실무에 복잡한 구조에서 서비스끼리 순환참조 관계를 가지는 경우에는 해당 서비스가 간단한 조회 목적으로 사용되고 있다면 DAO를 직접 주입하여 해결하는 방법도 있다.
    

<aside>
 필드 주입으로 순환 참조 오류를 당장에야 피할 수 있겠지만 순환 참조가 발생하는 설계는 객체 지향 관점에서 잘못된 설계이기 때문에 사전에 고쳐야한다.

</aside>


## 실무에서 발생한 순환참조 사례

앞서 말했듯이 **생성자 주입**을 사용하면 어플리케이션 기동 시점에 순환 참조 에러를 확인할 수 있었다.

필드 주입 관계에서 스프링에서 순환 참조 설계를 발견하는 것에 의문을 가졌고, 확인해보니 @Async 어노테이션으로 인해 발생하는 문제였다.

원인에 대한 추론으로 @Async가 있다면 스프링에서 해당 서비스 구현체를 프록시 빈으로 생성하는 과정에서 순환 참조 설계를 인식하고 throw하는 것 같다. 

## 참고
스프링의 세 가지 레벨의 캐시가 있다.

첫번째 레벨, singletonObjects - 인스턴스화, 주입 및 초기화 된 빈 인스턴스를 저장 용도

두번째 레벨, EarlySingletonObjects - 인스턴스화 된 빈 인스턴스 저장 용도

세번째 레벨, SingletonFactors - 빈 생성 팩토리, 이후 확장에서 프록시 객체 생성이 가능

핵심적으로 봤을 때 비동기 처리로 순환 참조를 발견하는 이유는 스프링에서 프록시 빈을 생성하는 과정에 프록시로 래핑하려는 인스턴스화 된 객체와 2차 캐시(EarlySingletonObjects)에 있는 객체가 서로 동일하지 않으면 순환 참조 예외가 발생시킨다.
