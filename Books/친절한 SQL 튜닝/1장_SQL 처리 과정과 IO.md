# 1. SQL 파싱과 최적화

## 1.1 구조적, 집합적, 선언적 질의 언어

- SQL은 구조적이고 집합적이고 선언적인 질의 언어이다.
- 원하는 결과집합을 구조적, 집합적으로 선언하지만 그 결과집합을 만드는 과정은 절차적이다.
    - 즉, 프로시저가 필요한데, 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 바로 SQL 옵티마이저이다.

## 1.2 SQL 파싱과 최적화

- DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 **SQL 최적화**라고 한다.
- SQL을 실행하기 전 최적화 과정을 세분화하면 아래와 같다.
    1. SQL 파싱
        - 사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서가 파싱을 잔행한다.
            - SQL 문법적 오류, 유효하지 않은 키워드, 존재하지 않는 테이블 또는 컬럼, 권한 등에 대한 검사
    2. SQL 최적화
        - 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택한다.
        - 옵티마이저는 데이터베이스 성능을 결정하는 가장 핵심적인 엔진이다.
    3. 로우 소스 생성
        - 옵티마이저가 선택한 실행경로를  로우 소스 생성기가 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계이다.

## 1.3 SQL 옵티마이저

- SQL 옵티마이저는 SQL 작업을 가장 효율적으로 수행할 수 있도록 최적의 데이터 접근 경로를 선택해 주는 DBMS의 핵심 엔진이다.
- 옵티마이저의 최적화 단계를 요약하면 아래와 같다.
    1. 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
    2. 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
    3. 최저 비용의 실행계획을 선택한다.

## 1.4 실행계획과 비용

- SQL 옵티마이저는 시스템에서 게산한 경로를 보여준다는 부분에서 네비게이션과 흡사하게 볼 수 있다.
- 네비게이션과 같이 경로를 미리 확인할 수 있으며, 만약 경로가 마음에 들지 않는다면 직접 변경할 수도 있다.
- 이와 같이 DBMS에서 SQL 실행 경로를 미리보는 기능을 **실행계획**이라고 한다.
- 실행계획의 Cost(비용)는 여러 통계정보를 활용해 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 가리키는 정보이다.
- 실행계획의 Cost는 예상치에 불과하며, 실제와 차이가 있다.

## 1.5 옵티마이저 힌트

- 옵티마이저가 제시하는 경로가 대부분 최적의 선택이지만, 100%는 아니다.
- 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도, 때도 있다.
- 이럴 때 옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있다.

# 2. SQL 공유 및 재사용

- 소프트 파싱과 하드 파싱의 차이점에 대해 살펴본다.
    - MySQL에서는 소프트 파싱이란 용어 대신에 쿼리 캐시를 찾아볼 수 있다.
- SQL 내부 최적화 과정의 복잡성과, 동시성 그리고 바인드 변수에 대한 중요성에 대해 살펴본다.

## 2.1 소프트 파싱 VS 하드 파싱

### 라이브러리 캐시

- 옵티마이저에서 내부적으로 생성한 프로시저를 반복 재사용이 가능하도록 캐싱해 두는 메모리 공간을 **라이브러리 캐시**라고 한다.
- 라이브러리 캐시는 SGA 구성요소이다.
- SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스 가능한 메모리 공간이다.

### 소프트 파싱과 하드 파싱

- 사용자가 SQL 문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지 확인한다.
    - 존재한다면, SQL을 캐시에서 찾아 곧바로 실행 단계에서 넘어가는 것을 **소프트 파싱**이라고 한다.
    - 존재하지 않는다면, 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 **하드 파싱**이라고 한다.
- 예로, 캐시 히트와 캐시 미스를 생각해볼 수 있겠다.

### SQL 최적화 과정은 왜 하드한가

- 옵티마이저는 SQL 최적화 시키는 과정에서 생각보다 아주 많은 작업과 연산을 수행한다.
- 옵티마이저가 SQL 최적화 하는 과정에서 사용하는 정보는 다음과 같다.
    - 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
    - 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
    - 시스템 통계: CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
    - 옵티마이저 관련 파라미터
- 하나의 SQL을 수행하는 데 있어 무수히 많은 실행계획을 도출하고, 짧은 순간에 딕셔너리와 통계정보를 읽어 효율성을 판단해내는 과정은 결코 가벼울 수 없다.
- 따라서 하드파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나이다.
- 이렇게 무거운(Hard) 작업을 거쳐 생성한 내부 프로시저를 일회성으로 사용하고 버린다면 양쪽 다 힘든 상황이 될 것이다.

## 2.2 바인드 변수의 중요성

### 이름없는 SQL 문제

- 프로시저, 함수 등은 생성 시 이름을 가지며 컴파일한 상태로 딕셔너리에 저장하여 영구적으로 보관한다.
- 반면에, SQL은 이름이 따로 없고 전체 SQL 텍스트 자체가 이름 역할을 한다.
- 처음 실행할 때 최적화 과정을 거쳐 동적 생성된 내부 프로시저를 라이브러리 캐시에 적재한다.
- 만약 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 과정을 거쳐 캐시에 적재된다.
- SQL이 이름을 갖지 못하는 이유에 대해
    - SQL은 수시로 변경이 일어나고, 일회성 SQL도 아주 많다.
    - 이를 모두 저장했다가는 공간이 부족해지며, 성능 또한 문제가 발생할 것이다.

### 공유 가능 SQL

- 라이브러리 캐시에서 SQL을 찾기 위해 사용되는 키 값은 SQL문 그 자체이다.
- 따라서 띄어쓰기 한 글자라도 다르다면, 이는 각각 다른 SQL로 간주된다.
    
    ```sql
    // 가리키는 의미와 결과는 동일하지만, 캐시는 다르게 본다.
    SELECT * FROM TB_USER;
    SELECT * FROM TB_USER ;
    ```
    
- 바인드 변수를 사용해야 하드파싱을 최소화하고, 자원 사용을 최소화할 수 있다.