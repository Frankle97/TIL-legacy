# 3장 설계 원칙

## 7장 SRP: 단일 책임 원칙
- 소프트웨어는 사용자와 이해관계자를 만족시키기 위해 변경된다.
- 변경을 요청하는 사용자나 관계자는 두 명 이상일 수 있으므로 변경을 요청하는 집단을 액터라고 부른다.
- **SRP**는 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다는 원칙이다.
- 중복, 병합 등의 문제 때문에 서로 다른 액터가 의존하는 코드들은 서로 분리해야 한다.


## 8장 OCP: 개방-폐쇄 원칙
- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
    - 다시 말해, 객체의 행위는 **확장**할 수 있어야 하지만, 기존 객체를 **수정해선 안된다.**
- 새로운 요구사항이 들어왔을 때, 기존 코드를 엄청나게 수정해야 한다면 문제가 많이 발생하게 될 것이다.
- 결국, 우리가 소프트웨어 아키텍처를 공부하는 근본적인 이유는 변화에 유연하게 대처하기 위해서라고 볼 수 있다.

- 소프트웨어 아키텍처가 훌룡하다면 새로운 요구사항이 들어오더라도 변경해야 하는 코드의 양을 최소화될 것이다.
- 아래의 원칙을 따르면 변경량을 최소화할 수 있다.
    - 변경되는 요소를 적절하게 분리 (SRP)
    - 요소 사이의 의존성을 체계화 (DIP)
- 컴포넌트 사이의 관계는 단방향으로 이루며, 방향은 변경으로부터 보호하기 위한 컴포넌트를 향한다.
    - A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하기 위해서는 A 컴포넌트가 B 컴포넌트에 의존해야 한다.

### 정리
- 아키텍처 수준에서의 OCP는 어떻게, 왜, 언제 발생하는지에 따라 기능을 분리하고, 컴포넌트의 계층구조로 조직화한다.
- 위 과정으로 **저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.**

## **9장 LSP: 리스코프 치환 원칙**

### **하위 타입이란**

치환의 개념을 인지하고 생각하고 아래 경우를 살펴보자.

>S 타입의 객체 Olive에 대응하는 T타입 객체 Material이 있고, T타입을 이용해 정의한 모든 프로그램에서 Material 자리에 Olive를 치환하더라도 프로그램의 행위가 변하지 않는다면, Olive는 Material의 하위 타입이다.

즉, 프로그램의 소스코드 변경없이 타입 Material을 Olive로 치환(교체)해도, 프로그램이 정상 동작할 수 있어야 한다는 원칙이다

### 타입에 의존하지 않는 구조

LSP를 준수하는 설계는 애플리케이션의 행위가 타입에 강하게 의존하지 않는다.

### LSP의 연혁

객체 지향 초창기에는 LSP는 상속을 사용하도록 가이드했지만, 시간이 지나면서 인터페이스와 구현체에도 적용되는 더 광범위한 설계 원칙으로 변모했다.

### 결론

LSP는 컴포넌트부터 아키텍처 수준까지 확장이 가능하고, 확장해야만 한다. 

치환 가능성을 고려하지 않으면 시스템이 오염될 확률이 아주 높아진다.