# 3장 패러다임 개요
## 구조적 프로그래밍
- 제어흐름의 **직접적인 전환**에 대해 규칙을 부과한다. 

## 객체 지향 프로그래밍
- 제어흐름의 **간접적인 전환**에 대해 규칙을 부과한다.

## 함수형 프로그래밍
- 할당문에 대해 규칙을 부과한다.

## 생각
- 각 패러다임은 프로그래머에게서 권한을 앗아간다.
- 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안되는지 말한다.
- 이러한 패러다임들이 등장한지 50년이 지났지만, 새로 등장한 패러다임이 없고 앞으로도 그럴 것이다.

## 결론
- 아키텍처 경계를 넘나들기 위해 다형성을 이용한다.
- 함수형 프로그래밍으로 데이터 위치와 접근 방법에 대해 규칙을 부과한다.
- 모듈 기반 알고리즘으로 구조적 프로그래밍을 사용한다.


# 4장 구조적 프로그래밍
## 증명
- 모든 프로그램은 **순차**, **분기**, **반복**이라는 세 가지 구조만으로 표현이 가능하다.
- 언어 자체에서 제어흐름을 제약 없이 직접 전환할 수 없으므로 우리는 모두 구조적 프로그래밍을 하고 있다.

## 기능적 분해
- 구조적 프로그래밍을 통해 재귀적으로 분해할 수 있게 되었고, 이로 인해 **모듈을 기능적으로 분해**할 수 있게 되었다.
  - 거대한 기술서를 받더라도 고수준의 기능들로 분해하고, 이를 또 저수준의 함수들로 분해하는 과정을 끝없이 반복하여 잘게 나눌 수 있다. 
- 즉, 대규모 시스템을 **모듈**과 **컴포넌트**로 나누고 입증 가능한 아주 **작은 기능들로 세분화**할 수 있다.

## 테스트
- 테스트를 통해 프로그램이 맞다고 증명할 수는 없지만, 어딘가 잘못된 것을 찾아낼 수는 있다. 
- 테스트가 보장할 수 있는 것은 **프로그램이 목표에 부합할 만큼은 충분히 참**이라고 여길 수 있게 하는 것이 전부이다.

## 결론
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.
- 아키텍처 관점에서 기능적 분해는 최고의 실천법 중 하나이다.

# 객체 지향 프로그래밍
- 좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.

# 함수형 프로그래밍