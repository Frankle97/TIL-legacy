# 3장 패러다임 개요
## 구조적 프로그래밍
- 제어흐름의 **직접적인 전환**에 대해 규칙을 부과한다. 

## 객체 지향 프로그래밍
- 제어흐름의 **간접적인 전환**에 대해 규칙을 부과한다.

## 함수형 프로그래밍
- 할당문에 대해 규칙을 부과한다.

## 생각
- 각 패러다임은 프로그래머에게서 권한을 앗아간다.
- 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안되는지 말한다.
- 이러한 패러다임들이 등장한지 50년이 지났지만, 새로 등장한 패러다임이 없고 앞으로도 그럴 것이다.

## 결론
- 아키텍처 경계를 넘나들기 위해 다형성을 이용한다.
- 함수형 프로그래밍으로 데이터 위치와 접근 방법에 대해 규칙을 부과한다.
- 모듈 기반 알고리즘으로 구조적 프로그래밍을 사용한다.


# 4장 구조적 프로그래밍
## 증명
- 모든 프로그램은 **순차**, **분기**, **반복**이라는 세 가지 구조만으로 표현이 가능하다.
- 언어 자체에서 제어흐름을 제약 없이 직접 전환할 수 없으므로 우리는 모두 구조적 프로그래밍을 하고 있다.

## 기능적 분해
- 구조적 프로그래밍을 통해 재귀적으로 분해할 수 있게 되었고, 이로 인해 **모듈을 기능적으로 분해**할 수 있게 되었다.
  - 거대한 기술서를 받더라도 고수준의 기능들로 분해하고, 이를 또 저수준의 함수들로 분해하는 과정을 끝없이 반복하여 잘게 나눌 수 있다. 
- 즉, 대규모 시스템을 **모듈**과 **컴포넌트**로 나누고 입증 가능한 아주 **작은 기능들로 세분화**할 수 있다.

## 테스트
- 테스트를 통해 프로그램이 맞다고 증명할 수는 없지만, 어딘가 잘못된 것을 찾아낼 수는 있다. 
- 테스트가 보장할 수 있는 것은 **프로그램이 목표에 부합할 만큼은 충분히 참**이라고 여길 수 있게 하는 것이 전부이다.

## 결론
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.
- 아키텍처 관점에서 기능적 분해는 최고의 실천법 중 하나이다.

# 객체 지향 프로그래밍
- 좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.
- 프로그래머가 관례를 지켜야 한다는 사실을 망각하게 되면 버그가 발생하고 찾아내고 없애기 어렵다.
- 객체 지향은 이러한 관례를 없애주며, 실수할 위험이 없다.

### 다형성
- 플러그인 아키텍처로 기존 프로그램에 **손을 대지 않고도 손쉬운 확장**을 가능케 한다.

### 의존성 역전
- 인터페이스를 두어 의존성 역전 구조로 만들 수 있다.
- 결합을 느슨하게 하여 모둘 별로 의존치 않고 **독립적**으로 만들 수 있으며, 모듈별 독립 배포, 수정이 가능하다. 


# 함수형 프로그래밍
- 함수형 언어에서 변수는 변경되지 않는다.
- Race Condition, Deadlock, Concurrency 문제들은 가변 변수로부터 발생하기 때문이다.
- 즉, 다수와 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 문제는 **불변**이라면 생기지 않는다.
- 애플리케이션을 제대로 구조화하려면 변경하는 컴포넌트와 변경하지 않는 컴포넌트들을 분리해야 한다.
- 가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내는 것이 좋다.