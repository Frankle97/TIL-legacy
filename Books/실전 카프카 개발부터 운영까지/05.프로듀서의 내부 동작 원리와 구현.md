# 프로듀서의 내부 동작 원리와 구현
## 파티셔너
- 카프카의 토픽은 **성능 향상을 위한 병렬 처리**가 가능토록 파티션으로 나뉘고, 최소 하나 또는 둘 이상의 파티션으로 구성된다.
- **파티셔너**는 프로듀서가 토픽의 어느 파티션으로 메시지를 전달해야 하는지 결정한다.
- 프로듀서가 파티션을 결정하기 위해 기본적으로 메시지의 키를 해시 처리하고, 전달받은 메시지의 키가 동일한 메시지들을끼리 동일 파티션으로 보낸다.
- 다만, 예상치 못한 양의 메시지가 인입된다면 카프카는 처리량을 높이기 위해 파티션을 늘릴 수 있다.
- 이때, 파티션 수가 변경되면 메시지 키와 매핑된 해시 테이블도 변경된다.
  - 기존과 달리 다른 파티션으로 전달될 수있다.
- 의도와 달리 다른 방식으로 메시지 전송이 이뤄질 수 있기에 되도록 파티션 수를 변경하지 않는 것이 좋다.

### 라운드 로빈 전략
- 앞서 말한 메시지 키 값은 필수가 아니므로 키 값을 지정하지 않고 메시지를 보낼 수 있다.
- 키 값은 null이 되고, 기본적으로 라운드 로빈 알고리즘으로 레코드들을 랜덤 전송한다.
- 카프카의 배치 처리를 위해선 메시지들을 잠시 프로듀서의 버퍼 메모리 영역에 응집해놓은 뒤 기준이 충족되면 메시지를 발송한다.
  - 라운드 로빈은 메시지를 랜덤의 파티션으로 뿌리고, 각 파티션마다 흩뿌려지면서 배치 기준이 충족이 되지 않아 전송되지 못하고 프로듀서 내에서 계속 대기하게 될 수 있다.
  - 예) 파티션의 배치 전송을 위한 최소 레코드 수가 3으로 설정된다.
    - 라운드 로빈으로 메시지가 각각 파티션 A,B,C로 보내졌고 파티션들은 2개의 메시지가 더 오기만을 기다려야 하는 상황이 발생 가능하다.

### 스티키 파티셔닝 전략
- 라운드 로빈 전략에서 latency가 불필요하게 증가되는 비효율적 전송을 발생하고자 카프카 2.4 버전 이후부터 스티키 파티셔닝 전략을 사용.
- **하나의 파티션에 레코드를 먼저 채워서** 카프카로 배치 전송을 빠르게 할 수 있도록 한다.

## 프로듀서의 배치
- 카프카는 토픽 처리량을 높이기 위해 토픽을 파티션으로 나누고, 프로듀서는 처리량을 높이기 위해 배치 전략을 사용한다.
- 프로듀서 배치 전송 옵션

| buffer.memory          | batch.size                  | linger.ms                            |
|------------------------|-----------------------------|--------------------------------------|
| 프로듀서의 버퍼 메모리, 기본값:32MB | 메시지를 묶는 단위의 배치 크기, 기본값:16KB | 버퍼 메모리에서 대기하는 메시지들의 최대 시간, 기본값:0(ms) |

- 버퍼 메모리의 크기는 충분해야 한다.
  - buffer.memory 크기는 batch.size보다 커야한다.


- 배치 전송으로 불필요한 I/O를 줄일 수 있다.
- 무조건 배치가 옳지는 않다. 지연 없는 처리가 필요한 경우 배치 처리는 독이 될 수 있다.
- 높은 처리량, 지연 없는 전송. 목적에 따라 프로듀서 옵션 값을 조정해가며 최적의 값을 찾아가는 것이 중요하다.
  - 정답은 없다.

## 전송 방식
- 메시지 시스템 전송 방식에는 **적어도 한 번 전송**, **최대 한 번 전송**, **정확히 한 번 전송**이 있다.

### 적어도 한 번 전송
- 일부 메시지 중복이 발생할 수 있지만, 최소한 하나의 메시지는 반드시 보장한다.

### 최대 한 번 전송
- 메시지 손실 가능성은 있지만, 중복 가능성은 없다.

### 중복 없는 전송
- 메시지는 PID와 메시지 번호를 갖는다.
- 브로커는 메시지의 PID를 메모리에 유지한다.
- PID는 프로듀서에 의해 자동 생성된다.
- 브로커는 메시지가 이미 저장되어 있는지 중복 여부를 확인한다.
- 만약 이미 저장되어 있다면, 프로듀서가 동일 메시지를 재전송 하더라도 브로커에는 메시지가 중복 저장되지 않는다.
- 브로커의 중복 체크 동작은 오버헤드가 발생하나, 그리 큰 편은 아니다.