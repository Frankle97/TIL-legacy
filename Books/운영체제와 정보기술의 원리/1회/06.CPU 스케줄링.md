# CPU 스케줄링

### CPU 개요
- CPU는 프로그램의 기계어 명령을 실제로 수행하는 **중앙 처리장치**이다.  
- 프로그램이 시작되어 메모리에 올라가면 **프로그램 카운터**라는 레지스터가 현재 CPU에서 수행할 코드의 **메모리 주소값을 보유**한다.
- CPU는 프로그램 카운터가 가리키는 주소의 **기계어 명령을 하나씩 수행**한다.
- CPU는 시스템 내에서 고유하므로 **여러 프로그램이 동시에 수행되는 시분할 환경**에서 매우 효율적으로 관리되어야 하는 자원이다.

### 기계어 명령 네 가지
- **CPU 내에서 수행되는 명령**
  - 예로 Add 명령이 있다. => CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령어.
  - CPU 내에서만 수행되므로 명령어의 **수행 속도가 매우 빠르다.**
- **메모리 접근을 필요로 하는 명령**
  - 예로 Load, Store 명령이 있다.
    - Load : 메모리에 있는 데이터를 CPU로 읽어들이는 명령.
    - Store : CPU에서 계산된 결괏값을 메모리에 저장하는 명령.
  - 메모리에 접근하는 명령은 상대적으로 **CPU 내에서 수행되는 명령보다는 소요되지만, 비교적 짧은 시간에 수행 가능한 명령**이다.
  - CPU 내에서 실행되는 명령과 더불어 메모리 접근 필요 명령은 모두 **사용자 프로그램이 직접 실행 가능한 일반명령**에 해당된다.
- **입출력을 동반하는 명령**
  - 위 두 명령에 비해 처리 속도가 매우 느리다.
  - 모든 입출력 명령은 **특권명령**으로 규정되있어 운영체제를 통해야 한다.

### 사용자 프로그램이 수행되는 과정
일종의 사이클과 같이 CPU 작업과 I/O 장치의 자원을 번갈아 사용하며 프로그램을 수행한다.  
CPU 내 수행 명령과 메모리 접근 명령은 비교적 빠른 일반 명령에 속하지만, I/O 명령은 CPU의 제어권이 운영체제 커널로 넘어가고 상대적으로 매우 느린 I/O 장치 접근을 필요로 한다.  

### 프로그램 수행은 두 단계의 조합으로 이루어진다.
- **사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 단계 > CPU 버스트**
  - 프로그램이 I/O를 한 번 수행하고 다음 번 I/O를 수행하기까지 직접 CPU를 갖고 명령을 수행하는 일련의 작업
- **I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계 > I/O 버스트**
  - I/O 작업이 요청부터 완료까지 마치고 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업

각 버스트에 비율은 균일하지 않다.  
어떤 프로세스는 I/O 버스트가 빈번해 CPU 버스트가 매우 짧을 수 있고, 반대일 수도 있다.  
이와 같은 기준에서 프로세스를 크게 아래와 같이 두 가지로 나누어 볼 수 있다.
- **CPU 바운드 프로세스**
  - I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스.
  - 상당 시간을 I/O 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램.
- **I/O 바운드 프로세스**
  - I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스.
  - 사용자로부터 인터랙션을 계속 받아가며 프로그램을 수행하는 대화형 프로그램.

## CPU 스케줄러
- CPU 스케줄러는 준비 상태의 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다.
- 프로세스가 CPU를 할당받아서 기계어 명령을 수행하다 타이머 인터럽트가 발생하면 CPU 스케줄러가 호출된다.
- CPU 스케줄러는 준비 큐에 있는 프로세스를 하나 선택해 CPU를 할당한다.


### CPU 스케줄러가 필요한 경우
  - 실행 상태에 있는 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우
  - 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
  - I/O 요청으로 봉쇄 상태에 있는 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 준비 상태로 바뀌는 경우
  - 실행 상태에 있는 프로세스가 종료되는 경우
  
### CPU 스케줄링 방식
- 비선점형 방식
  - CPU가 획득한 프로세스가 스스로 CPU를 반납하기 전까진 CPU를 빼앗기지 않는 방법.
- 선점형 방식
  - 프로세스가 CPU를 계속 사용하길 원해도 강제로 빼앗을 수 있는 방법.
    - 할당 시간을 부여한 뒤 타이머 인터럽트를 발생시키는 방법이 대표적.

## 디스패처
- 새로운 프로세스가 **CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제 코드를 디스패처**라고 한다.
- 디스패처는 **수행 중이던 프로세스 문맥을 그 프로세스의 PCB에 저장**하고 **새로운 프로세스의 문맥을 PCB로부터 복원하고 CPU에게 넘기는 과정**을 수행한다.
- 새로운 프로세스 문맥을 복원한 뒤 시스템 상태를 사용자 모드로 전환하고 사용자 프로그램에게 CPU 제어권을 넘긴다.
- 디스패처가 하나의 프로세스를 정지하고 다른 프로세스에게 CPU를 전달하기까지 소요되는 시간을 **디스패치 지연시간**이라고 하며, 대부분 문맥교환 오버헤드에 해당된다.

## 스케줄링의 성능 평가
스케줄링 기법 성능 평가를 위해 사용되는 지표는 크게 아래로 나누어볼 수 있다.
- **시스템 관점 지표**
  - CPU 이용률
    - 전체 시간 중 CPU가 일 한 시간의 비율.
      - CPU는 고비용 자원이므로 시스템 성능과 매우 밀접하며, CPU가 휴면(Idle) 상태에 머무르는 시간을 최대한 줄이는 것이 목표이다.
  - 처리량
    - 주어진 시간 동안 준비 큐에서 대기하는 프로세스를 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스 개수) 나타낸다.
      - 더 많은 프로세스가 CPU 작업을 완료하기 위해선, CPU 버스트가 짧은 프로세스부터 CPU를 할당하는 것이 유리하다.
- **사용자 관점 지표**
  - 소요시간
    - 프로세스가 CPU 요청한 시점부터 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간.
      - 준비 큐에서 기다린 시간 + 실제 CPU 사용 시간
  - 대기시간
    - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합.
  - 응답시간
    - 프로세스가 준비 큐에서 첫 번째 CPU를 획득하기까지 기다린 시간.

## 스케줄링 알고리즘
### 선입선출 스케줄링 (First-Come First-Served: FCFS)
- 프로세스가 준비 큐에 **도착한 순서에 따라 CPU를 할당**하는 방식.
- 먼저 요청한 프로세스에게 CPU를 할당하고, 그 프로세스가 자발적으로 CPU를 반납하기 전까지 빼앗지 않음.
- 합리적인 스케줄링 방식처럼 보이지만 **경우에 따라 비효율적인 결과를 초래**함.
  - 먼저 도착한 프로세스 성격에 따라 평균 대기시간이 크게 달라짐.
    - 만약 CPU 버스트가 긴 프로세스가 먼저 도착해서 처리되면 뒤에 가벼운 작업들이 불필요하게 기다리게 되면서 평균 대기시간이 늘어남.
      - 이를 **콘보이 현상** 이라고 하며, **FCFS 스케줄링의 대표적 단점**으로 꼽힌다.

### 최단작업 우선 스케줄링 (Shortest-Job First: SJF)
- **CPU 버스트가 가장 짧은 프로세스부터 먼저 CPU를 할당**하는 방식.
  - CPU 버스트가 짧은 프로세스부터 CPU를 먼저 사용하고 준비 큐를 빠져나가면서 전체적인 대기 시간이 줄일 수 있음.
- 평균 대기시간을 가장 짧게 하는 최적 알고리즘.


- 구현 방식
  - 비선점형 방식
    - CPU를 획득하면 해당 프로세스가 CPU를 자진 반납하기 전까지 CPU를 빼앗지 않음. 
  - 선점형 방식
    - CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했더라도, 나중에 더 짧은 프로세스가 도착하면 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식.
    
 
- 프로세스들이 준비 큐에 도착하는 시간이 불규칙한 환경에선 선점형 방식이 프로세스들의 평균 대기시간을 최소화하는 최적의 알고리즘.
- 일반적으로 시분할 환경에서 섡머형 방식이 평균 대기시간을 가장 많이 줄일 수 있는 방식.
  - 평균 대기시간을 최소화하는 알고리즘이지만, 항상 좋은 방식이라고 할 수 없다.
    - CPU 버스트가 짧은 프로세스에게만 CPU를 할당할 경우 CPU 버스트가 긴 프로세스는 준비 큐에서 무한정 대기하는 문제 발생 여지가 있다.
      - 이를 **기아 현상**이라고 하며, SJF 알고리즘의 치명적 단점이다.

## 우선순위 스케줄링 (Priority Scheduling)
- 준비 큐에서 기다리는 프로세스들 중 **우선순위가 높은 프로세스부터 CPU를 할당**하는 방식.
  - 우선순위 값으로 표현하며, 작을수록 높은 우선순위로 가정함.
- 우선순위 스케줄링 또한 SJF와 마찬가지로 비선점형, 선점형 방식으로 구현이 가능함.
- 기아 현상이 발생할 수 있음.
  - 우선순위가 높은 프로세스가 계속 도착하는 상황에서, 우선순위가 낮은 프로세스가 계속 대기 하는 상황.
    - **노화 기법**으로 대기 시간이 길어질 수록 우선 순위를 조금씩 높이는 방법.

## 라운드 로빈 스케줄링 (Round Robin Scheduling)
- 시분할 시스템의 성질을 가장 잘 활용한 스케줄링 방식.
- 각 프로세스가 CPU를 연속하여 사용하는 시간을 **특정 시간으로 제한**하고, 이 시간이 경과하면 CPU를 빼앗고 준비 큐의 다른 프로세스에 CPU를 할당하는 방식.
  - 빼앗은 프로세스를 준비 큐의 맨 뒤로 이동시키고 차례를 기다리게 함.
- 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간을 **할당시간**이라고 부름.
  - 할당시간이 너무 길면 FCFS와 같은 결과를 초래할 수 있음.
  - 할당시간이 너무 짧으면 CPU를 사용하는 프로세스간의 컨텍스트 스위칭이 빈번하게 일어나 오버헤드가 커질 수 있음.
- 목적 - CPU 버스트 시간이 짧은 프로레스부터 CPU를 할당하게 하고 동시에 CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것.

## 멀티레벨 큐(Multi-Level Queue)
- 준비 큐를 여러 개로 분할하여 관리하는 스케줄링 기법.
- 멀티레벨 큐는 일반적으로 성격이 다른 프로세스들을 별도 관리, 성격에 맞는 스케줄링을 적용하기 위한 준비 큐를 별도로 준비.
- 대화형 작업의 전위 큐
  - 응답시간을 최소화하기 위해 라운드 로빈 스케줄링을 사용.
- 계산 위주 작업의 후위 큐
  - 응답시간이 큰 의미를 갖지 않기에 FCFS 스케줄링을 사용.