# 서버측의 LAN에는 무엇이 있는가?

## 웹 서버의 설치 장소

- 클라이언트 PC는 가정 또는 회사에 설치되어 있지만, 서버는 가정이나 회사 안에만 있는 것은 아니다. 그렇다면 서버는 어디에 있는 것일까? 서버의 설치 장소에 대해 알아보자.

### 사내에 웹 서버를 설치하는 경우

- 인터넷부터 서버에 도착하기까지의 여정은 서버가 설치된 장소에 따라 다르다.
- 가장 간단한 방법은 사내 LAN에 서버를 설치하고, 인터넷에서 직접 액세스하는 것이다.
- 예전에는 이러한 형태로 서버를 설치하는 경우가 많았지만, 현재는 주류에서 밀려났다.
    - 사내 LAN에 설치한 기기에는 서버뿐만 아니라 클라이언트에도 글로벌 주소를 할당해야 하는데 **글로벌 주소의 여유가 부족**하다.
    - 보안에 취약하다.
- 특정 애플리케이션에 액세스하는 패킷만 통과시키고, 그 외 패킷을 차단하는 문지기 역할인 **방화벽**을 두는 방법이 일반적이다.
    - 액세스를 허가한 애플리케이션에 보안 구멍이 있을 수 있어서 완벽하지는 않지만 그래도 방화벽을 두어 보안적인 위험성을 크게 낮출 수 있다.

### 데이터센터에 웹 서버를 설치하는 경우

- 인터넷 중심에 고속 회선으로 접속되어 있기에 고속으로 접근이 가능하다.
- 상시 관리되는 장소이며 부가적인 모니터링 등 서비스를 제공받을 수 있어 **안정성** 또한 회사에 비해 높은 편이다.

## 방화벽의 원리와 동작

- 웹 서버 앞에는 보통 방화벽이 있는데, 방화벽이 어떻게 웹 서버를 지키는지 살펴보자.

### 패킷 필터링형이 주류이다

- 네트워크에는 다양한 패킷이 무수히 흐르고 있기에 방화벽이 이 중에 통과, 차단할 패킷을 선별하는 것은 간단한 일이 아니기에 다양한 방법이 존재한다.
    - 방화벽의 유형에는 **패킷 필터링형**, **애플리케이션 게이트웨이형**, **서킷 게이트웨이형**이 있다.
- 모두 방화벽 목적을 수행할 수 있지만, 성능, 가격, 사용 편의성 등의 이유로 현재는 **패킷 필터링형**이 가장 널리 보급되었다.

### 패킷 필터링형 방화벽

- 패킷 필터링형 방화벽은 수신처와 송신처의 IP 주소, 수신처와 송신처 포트 번호, 컨트롤 비트 등으로 패킷을 통과시킬지 판단한다.

### 방화벽을 통과한다

- 방화벽에는 여러 가지의 조건들이 설정되어 있다.
- 방화벽에 패킷이 도착하면 조건에 해당하는지 판정하고, 통과시킬지 차단시킬지를 결정한다.
- 차단하는 대상의 패킷은 버리고, 부정 침입의 흔적 등 분석 용도로 사용을 위해 버린 기록을 남긴다.
- 통과하는 대상의 패킷을 라우터와 같은 동작으로 패킷을 중계한다.

## 복수 서버에 리퀘스트를 분배한 서버의 부하 분산

### 처리 능력이 부족하면 복수 서버로 부하 분산된다

- 서버 액세스가 너무 많아진다면 서버 머신을 고성능으로 교체하여 해결할 수 있다.
- 하지만 서비스가 점점 커지면서 다수의 접속자가 집중적으로 액세스하는 상황에 서버 한 대로 운영하기에는 무리가 있을 수 있다.
- 이 때, 복수의 서버를 두어 각자 처리를 분담하여 처리량을 분산하는 것이 효과적이며, 이를 **분산 처리**라고 한다.
- 분산 처리 방법은 여러가지가 있는데, DNS 서버에서 분배하는 방법이 가장 간단하다.

#### 라운드 로빈
```markdown
A 도메인에 192.0.1.10, 192.0.1.20, 192.0.1.30 IP가 대응되어 있다고 가정한다.

첫번째 요청: 192.0.1.10, 192.0.1.20, 192.0.2.30이 회답한다.
두번째 요청: 192.0.1.20, 192.0.1.30, 192.0.2.10이 회답한다.
세번째 요청: 192.0.1.30, 192.0.1.10, 192.0.2.20이 회답한다.
```
- 이처럼 순환하여 균등하게 접근을 분산시키는 방식을 **라운드 로빈**이라고 한다.
- DNS에서의 라운드 로빈 방식은 웹 서버의 헬스체크가 어려우므로 고장난 서버가 있더라도 해당 서버의 IP를 회답하게 될 수 있다는 단점이 있다. 

### 부하 분산 장치를 이용해 복수의 웹 서버로 분할된다
- 로드 밸런서를 웹 서버 대신에 DNS에 등록하고, 클라이언트의 요청 메시지를 받고 웹 서버의 컨디션에 따라 웹 서버에 분할한다.


## 캐시 서버를 이용한 서버의 부하 분산

### 캐시 서버의 이용

- 캐시 서버는 **프록시** 구조를 사용하여 데이터를 캐시에 저장하는 서버이다.
- 프록시는 웹 서버와 클라이언트 사이에서 웹 서버에 대한 액세스 동작을 **중개**하는 역할을 한다.
- 액세스 동작을 중개하면서 웹 서버에서 받은 데이터를 디스크에 저장해 두고 웹 서버를 대신해 데이터를 클라이언트에게 반송하는 것을 **캐시**라고 부른다.
- 웹 서버는 URL 점검, 접근 권한 점검, 데이터 처리 등 웹 서버와 클라이언트 간의 리소스가 적지 않다.
- 따라서 웹서버에서 한 번 가져온 데이터를 캐시 서버에 적재해두고, 동일한 데이터 요청 시 웹 서버가 아닌 캐시 서버에서 해당 데이터를 제공하여 웹 서버의 피로를 줄인다.
- 이렇게 캐시 서버에서 리퀘스트를 처리하면 웹 서버의 부하를 줄이고 처리 시간을 단축할 수 있다.

### 캐시 서버는 갱신일로 콘텐츠를 관리한다

- 캐시 서버를 사용하기 위해서는 캐시 서버를 웹 서버 대신 DNS 서버에 등록한다.
- 사용자의 HTTP 요청은 캐시 서버로 가게 되고, 캐시 서버가 요청 메시지 내용을 조사하고, 데이터가 캐싱되어 있는지 확인한다.

#### 데이터가 캐싱되지 않았을 경우

![캐시_서버_과정.png](images/05_data_cache.png)

- 리퀘스트 메시지에 캐시 서버를 경유한 것을 나타내는 `Via` 헤더 필드를 추가해 웹 서버로 요청을 보낸다.
- 만약 하나의 캐시로 여러 대 서버의 데이터를 캐싱하고 있을 경우 송신할 대상 웹 서버를 판별하는 방법이 필요하다.
- 여러 가지 방법이 있지만 대표적인 방법으로 리퀘스트 메시지 URI의 디렉토리를 보고 판단한다.

```markdown
- URI에 /dir1/ 디렉토리가 있다면 www1.lab.cyber.co.kr에 전송
- URI에 /dir2/ 디렉토리가 있다면 www2.lab.cyber.co.kr에 전송 
```

- 전송 대상이 확인되면 캐시 서버가 웹 서버의 클라이언트가 되어 리퀘스트 메시지를 보낸다.
- 캐시 서버가 응답을 받으면 `Via` 헤더 필드를 추가하고 클아이언트에 대한 웹 서버가 되어 응답 메시지를 전송한 뒤, 응답 메시지를 캐싱하고 저장 일시를 기록한다.

#### 데이터가 캐싱되어 있을 경우

![cache_flow.jpeg](images/05_cache_flow.jpeg)

- 캐시 서버가 요청을 받고, 데이터가 캐시되어 있는지 확인하는 과정까지는 위와 동일하다.
- 데이터가 캐시되어 있다면 이 데이터가 변경되었는지 조사하기 위해 `If-Modified-Since` 헤더 필드를 추가하여 웹 서버에 전송한다.
- 만약 변경이 없으면 `303 Not Modified`, 변경이 있다면 웹 서버에서 최신 데이터를 반송한다.
- 웹 서버 입장에서는 데이터가 있으면 갱신 일시를 조사하는 것으로 끝나므로 매번 데이터를 가져오는 것에 비해 부담이 줄어든다.

### 프록시의 원점은 포워드 프록시

- 지금까지의 프록시 구조는 웹 서버측에 두어 캐시 기능을 이용하는 것이였지만, 클라이언트 측에 캐시 서버를 두는 **포워드 프록시**도 있다.
- 포워드 프록시가 처음 등장했을 때는 캐시 서버의 역할도 있지만, **방화벽을 실현**한다는 목적도 가지고 있었다.
- 인터넷과 사내 패킷을 프록시가 중개하고, 리퀘스트 메시지를 조사해 액세스 여부를 판별하는 방화벽 역할을 수행하며, 캐싱까지 더해 성능 향상까지 이룰 수 있다.
- 포워드 프록시를 사용하기 위해서는 브라우저 설정 항목에 포워드 프록시 IP 주소를 설정해야 한다.
- 잘못 설정할 경우 브라우저 동작의 장애 원인이 될 수 있다.

### 포워드 프록시를 개량한 리버스 프록시

- 포워드 프록시에 비해 브라우저에 프록시를 설정하지 않아도 사용 가능한 **리버스 프록시**가 나왔다.
- 서버측에 설치하는 캐시 서버에 채택하고 있는 방식이다.

### 트랜스페어런트 프록시

- **트랜스페어런트 프록시**는 패킷의 IP 헤더에 수신처 IP 주소를 통해 액세스 대상 웹 서버에 대해 알 수 있다.
- 브라우저에서 웹 서버로 리퀘스트 메시지가 흘러가는 길목에 트랜스페어런트 프록시를 설치하고, 메시지가 프록시를 통과할때 그것을 가로챈다.
- 사용자는 프록시의 존재를 알아차릴 필요가 거의 없기 때문에 HTTP 메시지를 전송한다는 구조에 관심이 적어지고 캐시를 이용한다는 측면에서 비중이 높아지고 있다.
