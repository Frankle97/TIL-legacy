# 메모리와 디스크의 핵심

2장에서 배운 조합 논리는 `흐름을 따른다.` 즉 조합 논리는 입력에 의해서만 출력이 결정된다. 하지만 좋바 논리만 사용해 컴퓨터를 만들 수 없다.

이번 장에서는 **순차 논리**를 배운다. 순차 논리는 순서에서 비롯된 용어다.

조합 논리는 입력의 현재 상태만을 다루지만 순차 논리는 입력의 현재 상태와 더불어 과거 상태를 함께 고려한다.
이번 장에서는 시간을 만들어내는 회로와 과거를 기억하기 위한 회로에 대해 배운다.

## 시간 표현과 상태 기억
우리는 **주기(periodic)** 함수를 사용해 시간을 측정할 수 있다.

컴퓨터는 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다.

### 발진자
정확한 발진자를 적은 비용으로 효율적으로 만드는 것은 크리스탈을 활용하는 것이며, 자석과 마찬가지로 크리스탈은 전기와도 관련이 있다.

**전극**을 크리스탈에 연결하고 크리스탈을 압축하면 크리스탈이 전기를 만들어내고, 전극에 전기를 가하면 크리스탈이 구부러지는데 이러한 현상을 **피에조 전기(압전)** 효과라고 부른다.

크리스탈은 음성 진동을 잡아낼 수 있어 마이크를 만들 때에 사용할 수도 있고, 전기를 가해 음성 진동을 만들어서 여러 전기 기구에서 다양한 경보음을 낼 수도 있다.

크리스털 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다.
**입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.**

### 클록
앞에서 보았듯 발진자를 사용하면 시간을 잘 측정할 수 있다.

하지만 시간이 중요한 다른 저수준의 이유가 존재한다.

2장에서 전파 지연이 회로가 작업을 수행하는 속도에 미치는 영향을 배웠다. 
예를 들어, 시간을 잴 수 있으면 결과가 안정적이고 올바르다고 확실할 수 있는 시점이 될 때까지 최악의 경우를 가정해 가산기의 지연 시간을 기다릴 수 있다.

발진자는 컴퓨터에 클록(시간을 셀 수 있게 해주는 신호)을 제공한다. 컴퓨터 클록은 드럼의 박자와 같이 회로의 페이스를 결정한다. 
회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정이 된다.

### 래치
이 회로는 값을 반전시키지 않기 때문에 발진자와는 달리 진동을 만들어내지는 않으며, 자신의 과거 상태를 기억한다.

하드웨어 기호 위에 선을 그으면 **반전**을 의미한다.
이 말은 값이 0일 때 참이고, 1일 때 거짓이라는 뜻이다.
이를 **액티브 하이(active high)** 에 반대되는 **액티브 로우(active low)** 라고 부른다.
이 말은 참을 표현하기 위해 액티브 하이의 1 대신 액티브 로우에서는 0을 사용한다는 뜻이다.

S-R 래치는 좀 더 똘똘하게 1비트 메모리를 만드는 방법이다. S-R은 *set-reset* 을 의미한다.
이들은 액티브 로우 입력을 받고 **보수** 출력을 제공한다. 보수 출력은 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우라는 뜻이다.

### 게이트가 있는 래치

### 플립플롭
데이터 변경으로 잘못된 결과를 초래하는 가능성을 최소화 하기에 가장 일반적으로 사용하는 방법은 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내는 것이다. 이런 전이를 **예지**라고 한다.
예지에 의해 데이터 변화가 촉발되는 래치를 **플립플롭** 이라고 부른다.

플립플롭을 만들 때는 래치를 기본 요소로 사용한다. 3개의 S-R 래치를 잘 연결하면 *양의 애지에 의해 변화가 촉발되는* 플립플롭을 만들 수 있고, 이를 **D 플립플롬** 이라고 부른다.
양의 에지에 의해 변화가 촉발된다라는 말은 논리 수준이 0에서 1로 바뀌는 순간 플립플롭의 출력이 바뀐다는 뜻이다.
반대로 *음에 에지에 의해 변화가 촉발되는* 플립플롭은 논리 수준이 1에서 0으로 바뀔 때 작동한다.

에지에서 상태가 변하는 플립플롭은 클록과 함께 쓰일 수 있다.

### 카운터
플립플롭을 응용한 회로 중에는 순서대로 수를 세는 카운터가 있다. 예를 들어 디지털 시계를 만들고 싶다면 발진자에서 나온 시간을 세고, 그 값을 디코더에 공급해서 숫자를 표시하는 디스플레이를 제어하면 된다.

각 비트의 상태가 다른 비트의 상태 변화에 약간 시차를 두고 바뀌기 때문에 이 회로를 **비동기 카운터** 라고 부른다.
비동기 시스템은 언제 결과를 살펴봐야 맞는지 알기 어렵다는 단점이 있다.

카운터를 사용하면 시간을 셀 수 있다.

### 레지스터
값을 기억하기 위해 D 플립플롭을 사용하여 *레지스터* 라는 회로를 쉽게 구할 수 있다.
레지스터는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.


## 메모리 조직과 주소 지정
비트를 단일로 기억할 때 플릷플롭이 유용하고, 여러 비트는 레지스터를 사용하면 쉽게 저장할 수 있다는 것을 알았다.
하지만 훨씬 더 많은 정보를 저장해야 한다면 레지스터를 많이 쌓아두는 것부터 시작할 수 있다.

메모리 칩에는 **주소 버스**와 **데이터 버스**가 있고, 버스는 비트를 이동시키는 대량 교통 수단을 의미한다.

### 임의 접근 메모리 (RAM)
**RAM(random access memory)** 을 사용하면 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 읽거나 쓸 수 있다.
**SRAM(정적 RAM)** 은 비싸지만 아주 빠르다. SRAM은 각 비트에 트랜지스터가 6개 들어간다.
트랜지스터는 공간을 차지하므로 SRAM은 수십억~수조의 비트를 저장하기에 좋은 선택지는 아니다.

**DRAM(동적 RAM)** 은 커패시터라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다. 문제는 이 버킷이 새기 때문에 가끔 메모리를 갱신해야 한다.

DRAM은 집적도(밀도, 단위 면적당 비트 개수)가 높으므로 큰 메모리 칩에 사용되며, 주소가 더 많고 멀티플렉싱을 사용해야 한다.

SRAM과 DRAM은 모두 전원이 꺼지면 데이터가 사라지는 **휘발성 메모리**이다.

### 읽기 전용 메모리 (ROM)
ROM은 한 번 쓰고 나면 여러번 읽을 수 있다. 임베디드와 같이 프로그램을 내장해야 하는 장치에서 ROM이 유용하다.

데이터를 일정한 순서로만 읽을 수 있는 *순차적* 메모리는 장기적으로 데이터를 저장하는 경우에만 유용하다.

### 블록 장치
대량 저장장치로 알려진 **디스크 드라이브**는 방대한 데이터를 담기에 좋은 장치다.
음식점의 서버(서빙하는 사람)과 같은 **디스크 헤드**가 사용자의 손 역할을 한다.

디스크 드라이브는 다른 유형의 메모리에 비해 상대적으로 느리지만 메모리와 반대로 비휘발성이다.

디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다. **블록**은 역사적으로 **섹터**라고 불려왔고, 디스크에서 읽고 쓰기가 가능한 가장 작은 단위다.

## 플래시 메모리와 SSD
**플래시 메모리**는 EEPROM 유형의 매체이며 음악 플레이어나 디지털 카메라 등의 응용에 적합하다.
DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동하지만 플래시 메모리의 버킷은 DRAM보다 더 크고 잘 만들어져 있어 전자가 새지 않는다.

플래시 메모리는 EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있으며, RAM처럼 원하는 위치를 읽을 수 있다.
플래시 메모리는 읽을 때는 임의 접근 장치이고 쓸 때는 블록 접근 장치이다.

디스크 드라이브는 점차 SSD로 널리 알려진 **고체 상태 드라이브(solid-state drive)** 로 교체되고 있다.
