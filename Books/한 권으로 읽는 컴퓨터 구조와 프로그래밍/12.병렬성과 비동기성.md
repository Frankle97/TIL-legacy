# 병렬성과 비동기성
- **멀티태스킹**은 컴퓨터가 한 번에 둘 이상의 작업을 수행하는 것
- 기존에는 CPU가 한 번에 한 가지의 일만 처리가 가능했다.
- 멀티코어 프로세서의 탄생으로 컴퓨터(CPU)는 한 번에 둘 이상의 일을 처리할 수 있게 되었다.

## 경쟁 상태 (Race Condition)
- **공유 자원에 둘 이상의 프로그램이 동시에 접근하여, 자원 사용 순서에 따라 결과가 다른** 경우를 뜻한다.

### 예시
- A와 B는 잔고가 100만원인 공동 계좌를 갖고 있다.
- A와 B가 같은 시각에 ATM에서 A가 계좌에서 75만원을 인출하고 있는데, B가 ATM에서 50만원을 인출하려고 시도한다.
- 이러한 경우를 **경쟁 상태(Race Condition)** 이라고 한다.
- 은행 프로그램은 **락(Lock)** 을 이용하여 한 사람에게만 돈을 지급해야 초과 인출을 막을 수 있다.
  - 특정 연산에선 멀티태스킹을 막아야한다는 의미가 된다.

## 공유 자원
- 메모리는 항상 공유 문제와 연관이 되고 심지어 공유 대상이 메모리가 아닌 경우에도 메모리와 관련된 경우가 많다.
  - 공유 자원이 사용 중인지 표현할 방법이 필요하기 때문
  - 이러한 메모리는 전형적인 메모리가 아닐 수 있음.
    - 예) 어떠한 입출력 장치 하드웨어의 비트

## 프로세스와 스레드
- 멀티코어 시스템에선 여러 프로그램이 병렬 처리되며, 병렬로 실행되는 프로그램이 자원을 공유하면 Race Condition이 발생할 수 있다.
- 프로세스끼리 자원을 공유하려면 통신을 해야 한다.  

### 스레드
- 정적 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분
- 한 스레드가 다른 스레드로 넘어가기 위해선 **스레드 스케줄러**가 CPU 레지스터를 저장해야 함.
  - 운영체제 Context Switch와 비슷
  - 프로세스보다 저장할 Context 크기가 훨씬 작기에 스레드 문맥 전환이 더 빠르고, 스레드를 다른 말로 **경량 프로세스**라고 부르기도 한다.
- 스레드는 데이터를 공유함으로써 보안 문제가 생길 수 있다.
- 한 스레드가 작업 처리에 너무 오랜 시간이 소요되고 있다면 다른 모든 스레드가 실행되지 못해 문제가 발생할 수 있다.

## 락
- 초점을 공유 자원이 아닌, 작업을 **원자적**으로 만드는 방법을 고민해야 한다.
  - 원자적: 나눌 수 없고 인터럽트할 수 없다는 뜻.
- 프로그램이 충돌을 피하기 위해 따르는 **어드바이저리 락**을 만들어서 달성한다.
- ![img.png](../../images/컴구_어드바이저리-락.png)
- Race Condition 에 대한 문제는 해결되었다. 
- **하지만**, 통신 문제가 발생한다면 락을 기다리는 다른 프로그램이 장시간 또는 계속해서 대기해야 하는 상황이 발생함으로써 멀티태스킹의 장점을 잃게 된다.

### 트랜잭션과 작업 크기
- 트랜잭션으로 묶인 모든 연산은 모두 성공하거나, 모두 실패한다.
- 락이 걸려 있는 시간이 길면 동시성이 줄어든다.
  - **락이 걸린 작업의 크기를 최소화**하라.

### 락 대기
- 프로그램이 락을 기다리면서 아무 일을 할 수 없다면 락을 세밀하게 만들어도 아무런 의미가 없다.
- 락을 기다리며 다른 작업을 수행할 일이 없을 수 있는데, 이땐 두 가지 방법이 있다.
  - 락을 얻을 때까지 락 획득을 지속 반복하여 시도할 수 있다.
    - 시도 간격을 조정하기 위해 타이머를 사용하는 경우도 있다.
    - 전력을 불필요하게 많이 소모한다.
    - 오픈런과 유사 논리
  - 락을 얻기 위한 프로그램에 **등록**하고 요청이 받아들여지면 **통지**를 받는다.
    - 규모를 쉽게 키우기 어려움.
    - 인터넷 아키텍처에서 직접적으로 지원되지는 않음.
- 일부 운영체제는 락 기능을 제공하고, 블로킹 또는 비블로킹으로 락을 요청할 수 있다.
  - **블로킹**:시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시중단 시킴.
  - **논블로킹**: 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 통지받음.

### 교착 상태 (Deadlock)
- 복잡한 시스템에서는 여러 락을 사용하는 경우도 있다.
- 프로그램 #1 이 락 A를 얻고, 프로그램 #2 가 락 B를 얻었을 경우
  - 프로그램 #1이 작업 수행을 마치고 락 B를 얻으려 하지만, 프로그램 #2가 락을 갖고 있어서 얻을 수 없음.
  - 마찬가지로 #2가 락 A를 얻으려 하지만, #1이 A를 갖고 있어서 얻을 수 없음.
  - **서로 락 해제 지점으로 진행될 수가 없음.**
    - 이를 교착 상태라고 한다.
- 교착 상태를 피하는 가장 좋은 해법은 코드를 잘 작성하는 것이다.

#### 교착 상태가 일어나는 원인
- 교착 상태가 발생하기 위해서는 함께 사용하는 프로세스(*스레드 등일 수도 있음*)가 아래 **네 가지의 조건을 동시에 만족**해야만 발생할 수 있다.
- 아래 중 하나라도 없다면 교착 상태는 발생하지 않는다.
  - 상호 배제: 공유 자원을 함께 쓸 수 없어 어느 한 프로세스가 독점하여 사용해야만 하는 것
  - 점유 대기: 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청함
  - 비선점: 프로세스가 할당받은 자원을 강제로 빼앗을 수 없음
  - 순환 대기: 각 프로세스가 서로 순환적으로 다른 프로세스의 자원을 요구함
- 교착 상태를 해소하기 위해선 다음과 같은 방법이 있고, 코드를 잘 작성해야 한다는 말이 **아래 방법 중 하나를 적용하여 해소**하란 의미이다.
  - 자원을 상호 배제하지 않고 언제든 공유 가능한 자원으로 만듦.
  - 어느 자원을 점유한 다음에 다른 자원을 요구하지 않고 한꺼번에 자원을 요구함.
  - 선점형으로 변경
  - 자원마다 우선순위를 부여해 모든 프로세스가 정해진 순서대로만 자원을 요구함

  
