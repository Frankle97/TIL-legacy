# 2.3 항상 인터페이스를 사용하세요
객체는 살아있는 동안 다른 객체들과 의사소통하며 서로 작업을 지원하고 도움을 제공한다. 이처럼 객체의 세계는 매우 사회적이면서 유대감 높은 환경이다.

다만, 여기서 말하고 싶은 부분은 객체들이 서로를 필요로 하기 때문에 서로 **결합(coupled)** 된다는 것이다.  
설계를 시작하는 단계에서는 각 객체가 어떤 일을 수행해야 하고 다른 객체에게 어떤 서비스를 제공하는지 정확히 알고 있는 편이 낫기에 결합이 유용하지만, 애플리케이션이 성장할수록 객체의 수도 많아짐에 따라 객체 사이의 **강한 결합**이 심각한 문제로 떠오르게 된다.  
결합도 문제는 애플리케이션의 **유지보수성에 나쁜 영향**을 미치고, 유지보수성을 좋게 유지하는 것은 매우 중요하다.

**객체를 분리**하면 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만들고, 이를 가장 가능케하는 가장 훌룡한 도구가 **인터페이스**이고 인터페이스는 객체 간의 의사소통을 위한 **약속**이다.

```java
interface Cash {
    Cash multiply(float factor);
}

class DefaultCash implements Cash {
    private int dollars;

    DefaultCash(int dlr) {
        this.dollars = dlr;
    }

    @Override
    public Cash multiply(float factor) {
        return new DefaultCash(this.dollars * factor);
    }
}
```

```java
class Employee {
    private Cash salary;
}
```
`Employee` 클래스는 `Cash`의 구현 방법, 동작 방식에 관심이 없고, 실제 `Cash`의 구현체가 다른 것으로 교체되더라도 `Employee`에게는 영향이 없다.
이처럼 인터페이스를 사용해 `Employee`와 `DefaultCache`를 느슨하게 분리할 수 있다.

추가적으로, 클래스 안의 모든 퍼블릭 메소드는 인터페이스를 구현해야 한다. 만약 다른 클래스가 인터페이스를 구현하지 않는 일반 퍼블릭 메서드를 사용한다면 서로 강하게 결합되기에 따라서 일반 퍼블릭 메서드는 클래스끼리 강하게 결합되는 것을 조장하는 셈이다.

동일한 인터페이스를 구현하는 여러 클래스가 존재들이 존재하고, 서로 대체가 가능해야 한다. 이것이 느슨한 결합도의 의미이다.

클래스도 인터페이스에 결합된 것이지만, 완전히 결합을 제거할 수는 없고 이러한 결합은 전체 시스템을 안정적인 상태로 유지하는 데 도움이 된다.

# 느낀점
클래스에 퍼블릭 메소드가 인터페이스의 구현체가 아닐 경우, 클래스 간의 강한 결합을 조장한다는 사실이 신선했다. 문장을 읽으며 완전 동의를 했지만, 평소에 의식하고 있지는 않았던 것 같다.

전체적으로 이번 절의 내용은 OCP와 연관이 깊은 것 같다.